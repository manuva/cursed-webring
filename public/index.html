<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="Microsoft FrontPage 4.1" />

    <!--   source code for this website:   https://github.com/revmischa/cursed-webring   -->

    <!--
 __  __     .    .     . __    _  _______   ___   .       ___     ___   _      _
 |   |     /|    /     / |\   |  '   /    .'   `. /     .'   `. .'   \   `.   /
 |___|    /  \   |     | | \  |      |    |     | |     |     | |          `./
 |   |   /---'\  |     | |  \ |      |    |     | |     |     | |    _     ,'
 /   / ,'      \  `._.'  |   \|      /     `.__.' /---/  `.__.'  `.___| _-'
     -->

    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta
      name="viewport"
      content="minimum-scale=1, initial-scale=1, width=device-width"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Cursed webring" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/apple-touch-icon.png" />
    <!-- <link rel="manifest" href="%PUBLIC_URL%/manifest.json" /> -->

    <!-- opengoof -->
    <meta property="og:url" content="https://www.cursed.lol" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Mischa's Cursed Webring" />
    <meta
      property="og:description"
      content="A webring comprising some of the most haunted and cursed websites on the internet."
    />
    <meta property="og:image" content="%PUBLIC_URL%/jesuswept.jpg" />

    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Nerko+One&display=swap"
      rel="stylesheet"
    />

    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-EK6ZDSMHHL"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-EK6ZDSMHHL");
    </script>

    <!-- loading grapics -->
    <script>
      // -- https://xemantic.github.io/shader-web-background/
      const shaderWebBackground = {};
      (() => {
        "use strict";
        const r = (a, b) => {
            b.initHalfFloatRGBATexture(b.width, b.height);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
          },
          x = (a, b) => {
            console.warn(
              "shader-web-background cannot shade, adding fallback CSS classes"
            );
            document.documentElement.classList.add(
              "shader-web-background-fallback"
            );
            b.classList.add("shader-web-background-fallback");
            if (a instanceof shaderWebBackground.GlError)
              console.warn("Not sufficient WebGL support:", a);
            else throw a;
          };
        function y(a, b) {
          if (!a) throw new shaderWebBackground.ConfigError(b);
        }
        function z(a) {
          y(
            a instanceof HTMLCanvasElement,
            "config.canvas must be instance of canvas"
          );
          return a;
        }
        function A() {
          const a = document.createElement("canvas"),
            b = a.style;
          a.id = "shader-web-background";
          b.width = "100vw";
          b.height = "100vh";
          b.position = "fixed";
          b.top = "0";
          b.left = "0";
          b.zIndex = -9999;
          return a;
        }
        const B = (a) => '<script type="x-shader/x-fragment" id="' + a + '">';
        function D(a) {
          const b = document.getElementById(a);
          y(b, "Missing shader source: " + B(a));
          y(
            b instanceof HTMLScriptElement && "x-shader/x-fragment" === b.type,
            'Shader source element of id "' + a + '" should be of type: ' + B(a)
          );
          return b.text;
        }
        function E(a, b) {
          "loading" !== document.readyState
            ? b()
            : window.addEventListener(a, b);
        }
        class F {
          constructor(a, b, c, d) {
            this.g = c;
            const k = a.gl;
            this.h = () => {
              for (const f of d) f.u(k, f.location, b);
            };
            this.i = () => {
              var f = c.v,
                h = a.gl;
              h.bindBuffer(h.ARRAY_BUFFER, a.j);
              h.enableVertexAttribArray(f);
              h.vertexAttribPointer(f, 2, h.FLOAT, !1, 0, 0);
              h.drawArrays(h.TRIANGLE_STRIP, 0, 4);
              h.disableVertexAttribArray(f);
              h.bindBuffer(h.ARRAY_BUFFER, null);
              f = a.gl;
              for (h = 0; h < a.g; h++)
                f.activeTexture(f.TEXTURE0 + h),
                  f.bindTexture(f.TEXTURE_2D, null);
              a.g = 0;
            };
          }
        }
        function G(a) {
          var b = { antialias: !1, depth: !1, alpha: !1 };
          try {
            return new H(a, b);
          } catch (c) {
            throw new shaderWebBackground.GlError(c.message);
          }
        }
        function I(a, b, c, d, k, f) {
          function h(e, m) {
            try {
              {
                var n = q;
                const p = n.gl,
                  v = J(
                    n,
                    e,
                    p.VERTEX_SHADER,
                    "attribute vec2 V;void main(){gl_Position=vec4(V,0,1);}"
                  ),
                  O = J(n, e, p.FRAGMENT_SHADER, m),
                  u = p.createProgram();
                p.attachShader(u, v);
                p.attachShader(u, O);
                p.linkProgram(u);
                var l = u;
              }
              return l;
            } catch (p) {
              throw new shaderWebBackground.ConfigError(p.message);
            }
          }
          const q = G(a),
            w = [],
            g = {
              gl: q.gl,
              canvas: a,
              width: 0,
              height: 0,
              cssPixelRatio: 0,
              cssWidth: 0,
              cssHeight: 0,
              isOverShader: (e, m) => {
                const n = a.getBoundingClientRect();
                return (
                  e >= n.left && e <= n.right && m >= n.top && m <= n.bottom
                );
              },
              toShaderX: (e) =>
                (e - a.getBoundingClientRect().left) * g.cssPixelRatio + 0.5,
              toShaderY: (e) =>
                a.height -
                (e - a.getBoundingClientRect().top) * g.cssPixelRatio -
                0.5,
              s: () =>
                g.cssWidth !== a.clientWidth || g.cssHeight !== a.clientHeight
                  ? (g.resize(), !0)
                  : !1,
              resize: () => {
                const e = window.devicePixelRatio || 1,
                  m = a.clientWidth,
                  n = a.clientHeight,
                  l = Math.floor(m * e),
                  p = Math.floor(n * e);
                a.width = l;
                a.height = p;
                g.width = l;
                g.height = p;
                g.cssPixelRatio = e;
                g.cssWidth = m;
                g.cssHeight = n;
                q.gl.viewport(0, 0, q.canvas.width, q.canvas.height);
                for (const v of w) v.g.l(l, p);
              },
              texture: (e, m) => {
                {
                  var n = q;
                  const l = n.gl;
                  m = m instanceof K ? m.g : m;
                  l.activeTexture(l.TEXTURE0 + n.g);
                  l.bindTexture(l.TEXTURE_2D, m);
                  l.uniform1i(e, n.g++);
                }
              },
              buffers: {},
              initHalfFloatRGBATexture: (e, m) => {
                q.h.g(e, m);
              },
            },
            P = Object.keys(b).length - 1;
          let Q = 0;
          for (const e in b) {
            if (Q++ < P) {
              const l = b[e].texture || r;
              g.buffers[e] = L(q, () => {
                l(q.gl, g);
              });
            }
            const m = M(q, h(e, D(e)), g.buffers[e]),
              n = b[e].uniforms || {};
            var t = Object.keys(n);
            for (const l of m.m)
              y(
                n[l.name],
                'No configuration for uniform "' +
                  l.name +
                  '" defined in shader "' +
                  e +
                  '"'
              ),
                (t = t.filter((p) => p !== l.name));
            0 !== t.length &&
              console.warn(
                'Extra uniforms configured for shader "' +
                  e +
                  '", which are not present in the shader code - might have been removed by GLSL compiler if not used: ' +
                  t.join(", ")
              );
            t = m.m.map((l) => ({ location: l.location, u: n[l.name] }));
            w.push(new F(q, g, m, t));
          }
          const C = () => {
            g.s() && d && d(g.width, g.height, g);
            k && k(g);
            for (const e of w) e.g.i(e.h, e.i);
            f && f(g);
            requestAnimationFrame(C);
          };
          E("load", () => {
            g.resize();
            c && c(g);
            d && d(g.width, g.height, g);
            requestAnimationFrame(C);
          });
          return g;
        }
        shaderWebBackground.Error = class extends Error {
          constructor(a) {
            super(a);
            this.name = "shaderWebBackground.Error";
          }
        };
        shaderWebBackground.ConfigError = class extends (
          shaderWebBackground.Error
        ) {
          constructor(a) {
            super(a);
            this.name = "shaderWebBackground.ConfigError";
          }
        };
        shaderWebBackground.GlError = class extends shaderWebBackground.Error {
          constructor(a) {
            super(a);
            this.name = "shaderWebBackground.GlError";
          }
        };
        shaderWebBackground.shade = function (a) {
          y(a, "Missing config argument");
          const b = a.canvas ? z(a.canvas) : A();
          y(a.shaders, "No shaders specified in config");
          try {
            const c = I(
              b,
              a.shaders,
              a.onInit,
              a.onResize,
              a.onBeforeFrame,
              a.onAfterFrame
            );
            a.canvas ||
              E("DOMContentLoaded", () => {
                document.body.appendChild(b);
              });
            return c;
          } catch (c) {
            (a.onError || x)(c, b);
          }
        };
        const N = [-1, 1, 1, 1, -1, -1, 1, -1];
        function R(a, b) {
          return a.j(a.gl.getExtension(b), b + " extension is not supported");
        }
        class S {
          constructor(a, b) {
            this.gl = a;
            this.j = b;
          }
          g() {}
        }
        class T extends S {
          constructor(a, b) {
            super(a, b);
            this.h = R(this, "OES_texture_half_float");
            R(this, "OES_texture_half_float_linear");
          }
          g(a, b) {
            const c = this.gl;
            c.texImage2D(
              c.TEXTURE_2D,
              0,
              c.RGBA,
              a,
              b,
              0,
              c.RGBA,
              this.h.HALF_FLOAT_OES,
              null
            );
          }
        }
        class U extends S {
          constructor(a, b) {
            super(a, b);
            R(this, "EXT_color_buffer_float");
            this.gl.getExtension("OES_texture_float_linear");
          }
          g(a, b) {
            const c = this.gl;
            c.texImage2D(
              c.TEXTURE_2D,
              0,
              c.RGBA16F,
              a,
              b,
              0,
              c.RGBA,
              c.HALF_FLOAT,
              null
            );
          }
        }
        function V(a) {
          a = a.split(/\r?\n/);
          const b = a.length.toString().length;
          var c = [];
          a.forEach((d, k) => {
            k = (k + 1).toString();
            k = k.length >= b ? k : " ".repeat(b - k.length) + k;
            c.push(k + ": " + d + "\n");
          });
          return c.join("");
        }
        function L(a, b) {
          return new K(a.gl, () => {
            b(a.gl);
          });
        }
        function M(a, b, c) {
          const d = a.gl;
          a = [];
          const k = d.getProgramParameter(b, d.ACTIVE_UNIFORMS);
          for (let f = 0; f < k; f++) {
            const h = d.getActiveUniform(b, f);
            a.push({ name: h.name, location: d.getUniformLocation(b, h.name) });
          }
          return {
            v: d.getAttribLocation(b, "V"),
            m: a,
            l: c ? (f, h) => c.l(f, h) : () => {},
            i: (f, h) => {
              d.useProgram(b);
              f();
              c ? ((f = c.g), (c.g = c.h), (c.h = f), c.i(h)) : h();
            },
          };
        }
        function J(a, b, c, d) {
          a = a.gl;
          c = a.createShader(c);
          a.shaderSource(c, d);
          a.compileShader(c);
          if (!a.getShaderParameter(c, a.COMPILE_STATUS)) {
            const k = String(a.getShaderInfoLog(c));
            a.deleteShader(c);
            b = "Cannot compile shader - " + b + ": " + k;
            console.log(b);
            console.log(V(d));
            throw Error(b);
          }
          return c;
        }
        class H {
          constructor(a, b) {
            this.canvas = a;
            const c = (k, f) => {
              if (!k) throw Error(f);
              return k;
            };
            let d = a.getContext("webgl2", b);
            if (d) this.h = new U(d, c);
            else if ((d = a.getContext("webgl", b))) this.h = new T(d, c);
            c(
              d,
              "webgl context not supported on supplied canvas element: " + a
            );
            this.gl = d;
            a = d.createBuffer();
            d.bindBuffer(d.ARRAY_BUFFER, a);
            d.bufferData(d.ARRAY_BUFFER, new Float32Array(N), d.STATIC_DRAW);
            d.bindBuffer(d.ARRAY_BUFFER, null);
            this.j = a;
            this.buffers = {};
            this.g = 0;
          }
        }
        function W(a) {
          const b = a.gl,
            c = b.createTexture();
          b.bindTexture(b.TEXTURE_2D, c);
          a.o(b);
          b.bindTexture(b.TEXTURE_2D, null);
          return c;
        }
        class K {
          constructor(a, b) {
            this.j = a.createFramebuffer();
            this.gl = a;
            this.o = b;
            this.g = this.h = null;
          }
          l() {
            this.h && this.gl.deleteTexture(this.h);
            this.g && this.gl.deleteTexture(this.g);
            this.h = W(this);
            this.g = W(this);
          }
          i(a) {
            const b = this.gl;
            b.bindFramebuffer(b.FRAMEBUFFER, this.j);
            b.framebufferTexture2D(
              b.FRAMEBUFFER,
              b.COLOR_ATTACHMENT0,
              b.TEXTURE_2D,
              this.g,
              0
            );
            a();
            b.framebufferTexture2D(
              b.FRAMEBUFFER,
              b.COLOR_ATTACHMENT0,
              b.TEXTURE_2D,
              null,
              0
            );
            b.bindFramebuffer(b.FRAMEBUFFER, null);
          }
        }
      })();
      //# sourceMappingURL=shader-web-background.min.js.map
    </script>

    <script type="x-shader/x-fragment" id="Image">
      precision mediump float;
      uniform float iTime;
      uniform vec2  iResolution;

      // https://www.shadertoy.com/view/lslGWr
      float field(in vec3 p) {
        float strength = 15. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));
        float accum = 0.;
        float prev = 0.;
        float tw = 0.;
        for (int i = 0; i < 24; ++i) {
          float mag = dot(p, p);
          p = abs(p) / mag + vec3(-.5, -.4, -1.5);
          float w = exp(-float(i) / 7.);
          accum += w * exp(-strength * pow(abs(mag - prev), 2.3));
          tw += w;
          prev = mag;
        }
        return max(0., 5. * accum / tw - .7);
      }

      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
        vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;
        vec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);
        vec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);
        p += .2 * vec3(sin(iTime / 256.), sin(iTime / 16.),  sin(iTime / 128.));
        float t = field(p);
        float v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));
        fragColor = mix(v, 1., .1) * vec4(1.8 * t * t * t, .5 * t * t, t, 1.0);
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    </script>
    <script>
      shaderWebBackground.shade({
        shaders: {
          Image: {
            uniforms: {
              iResolution: (gl, loc, ctx) =>
                gl.uniform2f(loc, ctx.width, ctx.height),
              iTime: (gl, loc) => gl.uniform1f(loc, performance.now() / 1000),
            },
          },
        },
        onAfterFrame: (ctx) => {
          ctx.iFrame++;
          if (window.stopCursedBackground) {
            const bg = document.getElementById("shader-web-background");
            if (bg) {
              document.body.removeChild(bg);
            }
          }
        },
      });
    </script>

    <title>Mischa's Cursed Webring</title>
  </head>
  <body>
    <noscript
      >You need to enable JavaScript to view this haunted website.</noscript
    >
    <div id="root"></div>
  </body>
</html>
